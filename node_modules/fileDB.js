/**
 * Created by Chris on 4/10/2015.
 */
var fs = require("fs");

function recursiveMkdir(path, cb){
	console.error("path: " + path);
	fs.mkdir(path, function(err){
		if(err && err.errno == 34){
			console.error(err);
			var token = '/';
			var newpath = path.split(token);
			newpath.pop();
			newpath = newpath.join(token);
			recursiveMkdir(newpath, function(){
				fs.mkdir(path, cb);
			});
		}
		else{
			cb();
		}
	});
}

var DIRECTORY = ['C:','hackathons2015','database'].join('/');
module.exports.Database = function(dbName, cb){
	// see if db exists, if not init
	var path = [DIRECTORY, dbName].join('/');
	var retval;
	try{
		fs.readDirSync(path);
	}
	catch(ignored){
		recursiveMkdir(path, function(){
			console.error("done");
		});
	}

	// create and return interface object
	return {
		'put': function (id, value, cb){
			// update value of specific element
			var path = [DIRECTORY,dbName,id].join('/');
			var str = JSON.stringify(value);
			fs.writeFile(path,str,function(err){
				if(err){
					console.error(err);
				}
				cb();
			});
		},
		'get': function (id, cb){
			// get value of specific element
			var path = [DIRECTORY,dbName,id].join('/');
			fs.readFile(path, function(err, data){
				if(err){
					console.error(err);
				}
				var value = JSON.parse(data);
				cb(err, value);
			});
		},
		'list': function(cb){
			var path = [DIRECTORY,dbName].join('/');
			// return map of all elements
			fs.readDir(path, function(err, filenames){
				if(err){
					console.error(err);
				}
				var values = [];
				for(var i=0;i<filenames.length;i++){
					(function(){
						// closure to save filename through to async cb scope
						var filename = filenames[i];
						var fpath = [path, filename].join('/');
						fs.readFile(fpath, function (err, data){
							if (err){
								console.error(err);
							}
							values[filename] = JSON.parse(data);
						});
					})();
				}
				cb(values);
			});

		}
	};
};

